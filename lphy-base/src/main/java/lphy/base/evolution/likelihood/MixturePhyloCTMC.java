package lphy.base.evolution.likelihood;

import lphy.base.distribution.Categorical;
import lphy.base.evolution.alignment.Alignment;
import lphy.base.evolution.tree.TimeTree;
import lphy.core.model.GenerativeDistribution;
import lphy.core.model.Generator;
import lphy.core.model.RandomVariable;
import lphy.core.model.Value;
import lphy.core.model.ValueUtils;
import lphy.core.model.annotation.GeneratorCategory;
import lphy.core.model.annotation.GeneratorInfo;
import lphy.core.model.annotation.ParameterInfo;
import lphy.core.simulator.RandomUtils;
import org.apache.commons.math3.random.RandomGenerator;

import java.util.Objects;
import java.util.SortedMap;
import java.util.TreeMap;

public final class MixturePhyloCTMC implements GenerativeDistribution<Alignment>, PhyloLikelihood {

    public static final String COMP1   = "comp1";
    public static final String COMP2   = "comp2";
    public static final String COMP3   = "comp3";
    public static final String WEIGHTS = "weights";
    public static final String INDEX   = "index";

    private Value<Alignment> comp1;
    private Value<Alignment> comp2;
    private Value<Alignment> comp3;
    private Value<Double[]>  weights;

    private Value<Integer>   index;
    private AbstractPhyloCTMC[] gens;
    private final RandomGenerator rng = RandomUtils.getRandom();

    public MixturePhyloCTMC(
            @ParameterInfo(name = COMP1, description = "First component alignment RV generated by a phylogenetic CTMC.")
            Value<Alignment> comp1,
            @ParameterInfo(name = COMP2, description = "Second component alignment RV generated by a phylogenetic CTMC.")
            Value<Alignment> comp2,
            @ParameterInfo(name = WEIGHTS, description = "Mixture weights (length 2 simplex).")
            Value<Double[]> weights,
            @ParameterInfo(name = INDEX, description = "Optional component index (0 or 1) used for SIMULATION ONLY; ignored when mapping to BEAST.", optional = true)
            Value<Integer> index
    ) {
        this.comp1   = Objects.requireNonNull(comp1,   "comp1 is required");
        this.comp2   = Objects.requireNonNull(comp2,   "comp2 is required");
        this.comp3   = null;
        this.weights = Objects.requireNonNull(weights, "weights is required");
        this.index   = index;
        rebuildGensAndValidate();
    }

    public MixturePhyloCTMC(
            @ParameterInfo(name = COMP1, description = "First component alignment RV generated by a phylogenetic CTMC.")
            Value<Alignment> comp1,
            @ParameterInfo(name = COMP2, description = "Second component alignment RV generated by a phylogenetic CTMC.")
            Value<Alignment> comp2,
            @ParameterInfo(name = COMP3, description = "Third component alignment RV generated by a phylogenetic CTMC.")
            Value<Alignment> comp3,
            @ParameterInfo(name = WEIGHTS, description = "Mixture weights (length 3 simplex).")
            Value<Double[]> weights,
            @ParameterInfo(name = INDEX, description = "Optional component index (0, 1 or 2) used for SIMULATION ONLY; ignored when mapping to BEAST.", optional = true)
            Value<Integer> index
    ) {
        this.comp1   = Objects.requireNonNull(comp1,   "comp1 is required");
        this.comp2   = Objects.requireNonNull(comp2,   "comp2 is required");
        this.comp3   = Objects.requireNonNull(comp3,   "comp3 is required");
        this.weights = Objects.requireNonNull(weights, "weights is required");
        this.index   = index;
        rebuildGensAndValidate();
    }

    private void rebuildGensAndValidate() {

        final int nComp = (comp3 == null) ? 2 : 3;

        Generator g1 = Objects.requireNonNull(comp1.getGenerator(),
                "comp1 must be produced by a phylo generator (e.g., PhyloCTMC)");
        Generator g2 = Objects.requireNonNull(comp2.getGenerator(),
                "comp2 must be produced by a phylo generator (e.g., PhyloCTMC)");

        if (!(g1 instanceof AbstractPhyloCTMC) || !(g2 instanceof AbstractPhyloCTMC)) {
            throw new IllegalArgumentException("comp1/comp2 must be generated by a PhyloCTMC-like generator.");
        }

        if (nComp == 2) {
            gens = new AbstractPhyloCTMC[]{ (AbstractPhyloCTMC) g1, (AbstractPhyloCTMC) g2 };
        } else {
            Generator g3 = Objects.requireNonNull(comp3.getGenerator(),
                    "comp3 must be produced by a phylo generator (e.g., PhyloCTMC)");
            if (!(g3 instanceof AbstractPhyloCTMC)) {
                throw new IllegalArgumentException("comp3 must be generated by a PhyloCTMC-like generator.");
            }
            gens = new AbstractPhyloCTMC[]{ (AbstractPhyloCTMC) g1, (AbstractPhyloCTMC) g2, (AbstractPhyloCTMC) g3 };
        }


        Double[] w = weights.value();
        if (w == null || w.length != nComp) {
            throw new IllegalArgumentException("MixturePhyloCTMC: weights must have length " + nComp + ".");
        }
        double s = ValueUtils.sum(weights);
        if (!Double.isFinite(s) || Math.abs(s - 1.0) > 1e-8) {
            throw new IllegalArgumentException("MixturePhyloCTMC: weights must sum to 1.0 (got " + s + ").");
        }

        if (gens[0].getTree() != gens[1].getTree()
                || (nComp == 3 && gens[2].getTree() != gens[0].getTree())) {
            throw new IllegalArgumentException("All components must reference the *same* TimeTree instance.");
        }

        if (index != null) {
            int k = index.value();
            if (k < 0 || k >= nComp) {
                throw new IllegalArgumentException("index must be in [0.." + (nComp - 1) + "] (got " + k + ").");
            }
        }
    }

    @GeneratorInfo(
            name = "MixturePhyloCTMC",
            verbClause = "is assumed to have evolved under a mixture of",
            narrativeName = "phylogenetic CTMC mixture",
            examples = {"mixtureLikelihood.lphy"},
            category = GeneratorCategory.PHYLO_LIKELIHOOD,
            description = "Mixture (convex combination) of two or three component phylogenetic likelihoods that apply to the same alignment."
    )
    @Override
    public RandomVariable<Alignment> sample() {
        final int nComp = (comp3 == null) ? 2 : 3;

        if (index != null) {
            int k = index.value();
            Alignment chosen;
            if (k == 0) {
                chosen = comp1.value();
            } else if (k == 1) {
                chosen = comp2.value();
            } else if (k == 2 && nComp == 3) {
                chosen = comp3.value();
            } else {
                throw new IllegalArgumentException("index out of range for " + nComp + " components: " + k);
            }

            if (chosen == null) {
                RandomVariable<Alignment> rv = gens[k].sample();
                chosen = rv.value();
            }
            return new RandomVariable<>("D", chosen, this);
        }

        int k = Categorical.sample(weights.value(), rng);
        RandomVariable<Alignment> rv = gens[k].sample();
        return new RandomVariable<>("D", rv.value(), this);
    }

    @Override
    public SortedMap<String, Value> getParams() {
        SortedMap<String, Value> map = new TreeMap<>();
        map.put(COMP1,   comp1);
        map.put(COMP2,   comp2);
        if (comp3 != null) map.put(COMP3, comp3);
        map.put(WEIGHTS, weights);
        if (index != null) map.put(INDEX, index);
        return map;
    }

    @SuppressWarnings("unchecked")
    @Override
    public void setParam(String name, Value value) {
        switch (name) {
            case COMP1   -> { this.comp1   = (Value<Alignment>) value; rebuildGensAndValidate(); }
            case COMP2   -> { this.comp2   = (Value<Alignment>) value; rebuildGensAndValidate(); }
            case COMP3   -> { this.comp3   = (Value<Alignment>) value; rebuildGensAndValidate(); }
            case WEIGHTS -> { this.weights = (Value<Double[]>)  value; rebuildGensAndValidate(); }
            case INDEX   -> { this.index   = (Value<Integer>)   value; rebuildGensAndValidate(); }
            default      -> throw new RuntimeException("Unrecognised parameter name: " + name);
        }
    }

    @Override public Value<TimeTree>  getTree()        { return gens[0].getTree(); }
    @Override public Value<Number>    getClockRate()   { return gens[0].getClockRate(); }
    @Override public Value<Double[]>  getBranchRates() { return gens[0].getBranchRates(); }
}
